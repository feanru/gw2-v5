import{getCached,setCached}from"./cache.js";import fetchWithRetry from"./fetchWithRetry.js";import apiHealth from"./apiHealth.js";import config from"../config.js";const GW2_ITEMS_ENDPOINT=`${config.API_BASE_URL}/items?ids=`,LANG_PARAM=`&lang=${config.LANG}`,MAX_BATCH=200,FLUSH_MS=50,queue=new Set,pending=new Map;let timer=null,controller=null;function buildHeaders(e){if(1!==e.length)return{};const t=getCached(`item_${e[0]}`,!0);if(!t)return{};const r={};return t.etag&&(r["If-None-Match"]=t.etag),t.lastModified&&(r["If-Modified-Since"]=t.lastModified),r}function preloadCache(){if("undefined"!=typeof localStorage)for(let e=0;e<localStorage.length;e++){const t=localStorage.key(e);t.startsWith("item_")&&getCached(t)}}function scheduleFlush(){timer||(timer=setTimeout(flush,50)),queue.size>=200&&(clearTimeout(timer),flush())}async function flush(){if(0===queue.size)return void(timer=null);timer=null;const e=Array.from(queue).slice(0,200);e.forEach(e=>queue.delete(e));try{const t=apiHealth.getBackoff();t&&await new Promise(e=>setTimeout(e,t)),controller=new AbortController;const r=await fetchWithRetry(GW2_ITEMS_ENDPOINT+e.join(",")+LANG_PARAM,{headers:buildHeaders(e),signal:controller.signal,backoff:300+t});if(304===r.status)return void e.forEach(e=>{const t=pending.get(e),r=getCached(`item_${e}`);t&&t.resolve(r),pending.delete(e)});const o=r.headers.get("ETag"),n=r.headers.get("Last-Modified"),i=await r.json(),l=new Map(i.map(e=>[e.id,e]));e.forEach(e=>{const t=pending.get(e),r=l.get(e);r?(setCached(`item_${e}`,r,void 0,{etag:o,lastModified:n}),t.resolve(r)):t.resolve(null),pending.delete(e)})}catch(t){e.forEach(e=>{const r=pending.get(e);r&&(t instanceof DOMException&&t.name,r.reject(t)),pending.delete(e)})}queue.size>0&&scheduleFlush()}preloadCache();export function requestItems(e=[],t){controller&&(controller.abort(),controller=null),t&&t.addEventListener("abort",()=>controller&&controller.abort(),{once:!0});const r=e.map(e=>{const t=getCached(`item_${e}`);if(t)return Promise.resolve(t);if(pending.has(e))return pending.get(e).promise;const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),pending.set(e,r),queue.add(e),scheduleFlush(),r.promise});return Promise.all(r)}export function abortRequests(){controller&&(controller.abort(),controller=null),queue.clear(),pending.forEach(e=>e.reject(new DOMException("Aborted","AbortError"))),pending.clear(),timer&&(clearTimeout(timer),timer=null)}