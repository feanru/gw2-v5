{"version":3,"file":"utils-BAeLe99y.js","sources":["../../src/js/utils/apiHealth.js","../../src/js/utils/fetchWithRetry.js","../../src/js/utils/cachePolicies.js","../../src/js/utils/cacheSync.js","../../src/js/utils/cache.js","../../src/js/utils/requestCache.js","../../src/js/config.js","../../src/js/utils/priceHelper.js","../../src/js/utils/priceUpdater.js","../../src/js/utils/requestManager.js","../../src/js/utils/stateManager.js","../../src/js/utils/lazyLoader.js"],"sourcesContent":["const failureTimestamps = [];\nconst WINDOW_MS = 60000; // 1 minute\nconst DOWN_THRESHOLD = 5;\n\nfunction cleanup() {\n  const cutoff = Date.now() - WINDOW_MS;\n  while (failureTimestamps.length && failureTimestamps[0] < cutoff) {\n    failureTimestamps.shift();\n  }\n}\n\nfunction recordFailure() {\n  failureTimestamps.push(Date.now());\n  cleanup();\n  updateIndicator();\n}\n\nfunction recordSuccess() {\n  cleanup();\n  updateIndicator();\n}\n\nfunction getState() {\n  cleanup();\n  const fails = failureTimestamps.length;\n  if (fails > DOWN_THRESHOLD) return 'down';\n  if (fails > 0) return 'slow';\n  return 'ok';\n}\n\nfunction getBackoff() {\n  const state = getState();\n  if (state === 'down') return 5000;\n  if (state === 'slow') return 1000;\n  return 0;\n}\n\nlet indicatorEl;\nfunction updateIndicator() {\n  if (typeof document === 'undefined') return;\n  const state = getState();\n  if (!indicatorEl) {\n    indicatorEl = document.createElement('div');\n    indicatorEl.id = 'api-status-indicator';\n    indicatorEl.style.position = 'fixed';\n    indicatorEl.style.bottom = '10px';\n    indicatorEl.style.right = '10px';\n    indicatorEl.style.padding = '4px 8px';\n    indicatorEl.style.background = 'rgba(0,0,0,0.7)';\n    indicatorEl.style.color = '#fff';\n    indicatorEl.style.borderRadius = '4px';\n    indicatorEl.style.zIndex = '10000';\n    indicatorEl.style.display = 'none';\n    document.body.appendChild(indicatorEl);\n  }\n  if (state === 'ok') {\n    indicatorEl.style.display = 'none';\n  } else {\n    indicatorEl.textContent = state === 'slow' ? 'API lenta' : 'API ca√≠da';\n    indicatorEl.style.display = 'block';\n  }\n}\n\nexport default {\n  recordFailure,\n  recordSuccess,\n  getState,\n  getBackoff\n};\n","import apiHealth from './apiHealth.js';\n\nexport { apiHealth };\n\nexport default async function fetchWithRetry(url, options = {}) {\n  const {\n    timeout = 8000,\n    retries = 3,\n    backoff = 300,\n    signal,\n    ...fetchOptions\n  } = options;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    if (signal) {\n      if (signal.aborted) {\n        controller.abort();\n      } else {\n        signal.addEventListener('abort', () => controller.abort(), { once: true });\n      }\n    }\n\n    try {\n      const response = await fetch(url, { ...fetchOptions, signal: controller.signal });\n      clearTimeout(timeoutId);\n      apiHealth.recordSuccess();\n      return response;\n    } catch (err) {\n      clearTimeout(timeoutId);\n      apiHealth.recordFailure();\n      if (signal?.aborted || attempt === retries) throw err;\n      const delay = backoff * Math.pow(2, attempt);\n      await new Promise((res) => setTimeout(res, delay));\n    }\n  }\n}\n","/**\n * Centralized cache expiration policies (milliseconds).\n * \n * - `item`: Item details from the GW2 API. These rarely change, so we cache indefinitely.\n * - `recipe`: Recipe data from the GW2 API. Also stable, cached indefinitely.\n * - `price`: Market price data. Fluctuates quickly, expires after 5 minutes.\n * - `history`: Hourly history data. Voluminous but relatively stable, expires after 24 hours.\n */\nexport const CACHE_TTLS = {\n  item: null,\n  recipe: null,\n  price: 5 * 60 * 1000,\n  history: 24 * 60 * 60 * 1000,\n  bundle: 5 * 60 * 1000,\n};\n\nexport default CACHE_TTLS;\n","const channel = (typeof window !== 'undefined' && 'BroadcastChannel' in window)\n  ? new BroadcastChannel('cache-sync')\n  : null;\n\nlet store = null;\n\nexport function setupCacheSync(cacheStore) {\n  store = cacheStore;\n  if (!channel) return;\n  channel.addEventListener('message', ({ data }) => {\n    const { type, key, entry } = data || {};\n\n    if (type === 'request-bundles') {\n      // Send all cached bundle entries to the requester\n      if (!store) return;\n      store.forEach((e, k) => {\n        if (k.startsWith('bundle_')) {\n          channel.postMessage({ type: 'set', key: k, entry: e });\n        }\n      });\n      return;\n    }\n\n    if (!type || !key) return;\n    if (type === 'set' && entry) {\n      store.set(key, entry);\n    } else if (type === 'delete') {\n      store.delete(key);\n    }\n  });\n}\n\nexport function notifySet(key, entry) {\n  if (!channel) return;\n  channel.postMessage({ type: 'set', key, entry });\n}\n\nexport function notifyDelete(key) {\n  if (!channel) return;\n  channel.postMessage({ type: 'delete', key });\n}\n\nexport function requestBundleSync() {\n  if (!channel) return;\n  channel.postMessage({ type: 'request-bundles' });\n}\n","import CACHE_TTLS from './cachePolicies.js';\nimport { setupCacheSync, notifySet, notifyDelete, requestBundleSync } from './cacheSync.js';\nimport fetchWithRetry from './fetchWithRetry.js';\n\nconst cacheStore = new Map();\nsetupCacheSync(cacheStore);\nrequestBundleSync();\nconst STORAGE_AVAILABLE = typeof localStorage !== 'undefined';\nconst inFlight = new Map();\n\nfunction requestKey(url, { method = 'GET', headers = {} } = {}) {\n  return `${url}|${method.toUpperCase()}|${JSON.stringify(headers)}`;\n}\n\nfunction serializeEntry({ value, expiresAt, etag, lastModified }) {\n  return JSON.stringify({ value, expiresAt, etag, lastModified });\n}\n\nfunction deserializeEntry(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}\n\nfunction writeStorage(key, entry) {\n  if (!STORAGE_AVAILABLE) return;\n  try {\n    localStorage.setItem(key, serializeEntry(entry));\n  } catch {\n    // ignore storage errors (quota, etc.)\n  }\n}\n\nfunction readStorage(key) {\n  if (!STORAGE_AVAILABLE) return null;\n  const raw = localStorage.getItem(key);\n  if (!raw) return null;\n  const data = deserializeEntry(raw);\n  if (!data) {\n    localStorage.removeItem(key);\n    return null;\n  }\n  return data;\n}\n\nfunction cleanExpired() {\n  if (!STORAGE_AVAILABLE) return;\n  const keysToRemove = [];\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    const data = deserializeEntry(localStorage.getItem(key));\n    if (!data) continue;\n    const { expiresAt } = data;\n    if (expiresAt && Date.now() > expiresAt) keysToRemove.push(key);\n  }\n  keysToRemove.forEach((k) => {\n    localStorage.removeItem(k);\n    notifyDelete(k);\n  });\n}\n\ncleanExpired();\n\nexport function setCached(key, value, ttlMs = undefined, meta = {}) {\n  if (ttlMs === undefined) {\n    const prefix = key.split('_')[0];\n    ttlMs = CACHE_TTLS[prefix];\n  }\n  const expiresAt = ttlMs == null ? null : Date.now() + ttlMs;\n  const { etag = null, lastModified = null } = meta;\n  const entry = { value, expiresAt, updatedAt: new Date().toISOString(), etag, lastModified };\n  cacheStore.set(key, entry);\n  writeStorage(key, { value, expiresAt, etag, lastModified });\n  notifySet(key, entry);\n}\n\nexport function getCached(key, withMeta = false) {\n  let entry = cacheStore.get(key);\n  if (!entry) {\n    const data = readStorage(key);\n    if (data) {\n      const { value, expiresAt = null, etag = null, lastModified = null } = data;\n      entry = { value, expiresAt, updatedAt: new Date().toISOString(), etag, lastModified };\n      cacheStore.set(key, entry);\n    }\n  }\n  if (!entry) return null;\n  if (entry.expiresAt && Date.now() > entry.expiresAt) {\n    cacheStore.delete(key);\n    if (STORAGE_AVAILABLE) localStorage.removeItem(key);\n    notifyDelete(key);\n    return null;\n  }\n  return withMeta ? entry : entry.value;\n}\n\nexport function fetchDedup(url, options = {}) {\n  const key = requestKey(url, options);\n  const base =\n    inFlight.get(key) ||\n    fetchWithRetry(url, options).finally(() => inFlight.delete(key));\n  inFlight.set(key, base);\n  return base.then((res) => res.clone());\n}\n\nexport default {\n  getCached,\n  setCached,\n  fetchDedup\n};\n\n","import { getCached } from './cache.js';\nimport fetchWithRetry from './fetchWithRetry.js';\n\nconst activeRequests = new Map();\n\nexport function getRequest(url) {\n  return activeRequests.get(url)?.promise;\n}\n\nfunction setRequest(url, promise, controller) {\n  activeRequests.set(url, { promise, controller });\n  promise.finally(() => activeRequests.delete(url));\n  return promise;\n}\n\nexport function abortRequest(url) {\n  const entry = activeRequests.get(url);\n  if (entry?.controller) entry.controller.abort();\n}\n\nexport function fetchWithCache(url, options = {}, cacheKey = null, cached = null, signal) {\n  const existing = activeRequests.get(url);\n  if (existing) existing.controller?.abort();\n\n  if (cacheKey && !cached) {\n    cached = getCached(cacheKey, true);\n  }\n\n  const headers = { ...(options.headers || {}) };\n  if (cached?.etag) headers['If-None-Match'] = cached.etag;\n  if (cached?.lastModified) headers['If-Modified-Since'] = cached.lastModified;\n\n  const controller = signal ? null : new AbortController();\n  const fetchSignal = signal ?? options.signal ?? controller?.signal;\n\n  const promise = fetchWithRetry(url, { ...options, headers, signal: fetchSignal }).then(async (response) => {\n    if (response.status === 304 && cached) {\n      return new Response(JSON.stringify(cached.value), {\n        status: 200,\n        headers: {\n          'X-Cache': 'HIT',\n          'ETag': cached.etag || '',\n          'Last-Modified': cached.lastModified || ''\n        }\n      });\n    }\n    return response;\n  }).catch(err => {\n    if (err instanceof DOMException && err.name === 'AbortError') throw err;\n    throw err;\n  });\n\n  return setRequest(url, promise, controller).then(r => r.clone());\n}\n\nexport default {\n  fetchWithCache,\n  getRequest,\n  setRequest: (url, promise) => setRequest(url, promise, null),\n  abortRequest\n};\n","const ENV = (typeof process !== 'undefined' && process.env) ? process.env : {};\n\nexport const API_BASE_URL = ENV.API_BASE_URL || 'https://api.guildwars2.com/v2';\nexport const LANG = ENV.LANG || 'es';\nexport const MARKET_CSV_URL = ENV.MARKET_CSV_URL || 'https://api.datawars2.ie/gw2/v1/items/csv';\nexport const GW2_API_KEY = ENV.GW2_API_KEY || '';\nexport const priceCacheStrategy = ENV.PRICE_CACHE_STRATEGY || 'sessionStorage';\n\nexport default {\n  API_BASE_URL,\n  LANG,\n  MARKET_CSV_URL,\n  GW2_API_KEY,\n  priceCacheStrategy\n};\n","import config from '../config.js';\n\nconst memoryCache = new Map();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nfunction isSessionStrategy() {\n  return (config?.priceCacheStrategy || 'sessionStorage') === 'sessionStorage';\n}\n\nfunction storageKey(id) {\n  return `price_${id}`;\n}\n\nfunction loadFromSession(id) {\n  if (!isSessionStrategy() || typeof sessionStorage === 'undefined') return null;\n  const raw = sessionStorage.getItem(storageKey(id));\n  if (!raw) return null;\n  try {\n    const { value, expires } = JSON.parse(raw);\n    if (expires && Date.now() > expires) {\n      sessionStorage.removeItem(storageKey(id));\n      return null;\n    }\n    return value;\n  } catch {\n    sessionStorage.removeItem(storageKey(id));\n    return null;\n  }\n}\n\nfunction saveToSession(id, value) {\n  if (!isSessionStrategy() || typeof sessionStorage === 'undefined') return;\n  try {\n    sessionStorage.setItem(\n      storageKey(id),\n      JSON.stringify({ value, expires: Date.now() + CACHE_TTL })\n    );\n  } catch {\n    // ignore storage errors\n  }\n}\n\nasync function fetchPrices(ids) {\n  if (!Array.isArray(ids) || ids.length === 0) return new Map();\n  if ((config?.priceCacheStrategy || 'sessionStorage') === 'redis') {\n    const url = `/backend/api/itemBundle.php?ids=${ids.join(',')}`;\n    const resp = await fetch(url);\n    if (!resp.ok) throw new Error('Price fetch failed');\n    const arr = await resp.json();\n    const out = new Map();\n    arr.forEach(entry => {\n      const m = entry.market || {};\n      out.set(entry.id, { buy_price: m.buy_price || 0, sell_price: m.sell_price || 0 });\n    });\n    return out;\n  } else {\n    const fields = ['id', 'buy_price', 'sell_price'].join(',');\n    const url = `https://api.datawars2.ie/gw2/v1/items/csv?fields=${fields}&ids=${ids.join(',')}`;\n    const resp = await fetch(url);\n    if (!resp.ok) throw new Error('Price fetch failed');\n    const text = await resp.text();\n    const lines = text.trim().split('\\n');\n    const headers = lines[0].split(',');\n    const out = new Map();\n    for (let i = 1; i < lines.length; i++) {\n      if (!lines[i]) continue;\n      const values = lines[i].split(',');\n      const obj = {};\n      headers.forEach((h, idx) => {\n        const v = values[idx];\n        obj[h] = v !== undefined ? (isNaN(v) ? v : Number(v)) : null;\n      });\n      if (obj.id != null) {\n        out.set(obj.id, { buy_price: obj.buy_price || 0, sell_price: obj.sell_price || 0 });\n      }\n    }\n    return out;\n  }\n}\n\nexport async function preloadPrices(ids = []) {\n  const result = new Map();\n  const toFetch = [];\n  ids.forEach(id => {\n    id = Number(id);\n    if (memoryCache.has(id)) {\n      result.set(id, memoryCache.get(id));\n      return;\n    }\n    const stored = loadFromSession(id);\n    if (stored) {\n      memoryCache.set(id, stored);\n      result.set(id, stored);\n    } else {\n      toFetch.push(id);\n    }\n  });\n  if (toFetch.length) {\n    try {\n      const fetched = await fetchPrices(toFetch);\n      fetched.forEach((data, id) => {\n        memoryCache.set(id, data);\n        saveToSession(id, data);\n        result.set(id, data);\n      });\n    } catch (e) {\n      console.error('Error preloading prices', e);\n    }\n  }\n  ids.forEach(id => {\n    id = Number(id);\n    if (!result.has(id) && memoryCache.has(id)) result.set(id, memoryCache.get(id));\n    if (!result.has(id)) result.set(id, { buy_price: 0, sell_price: 0 });\n  });\n  return result;\n}\n\nexport async function getPrice(id) {\n  id = Number(id);\n  if (memoryCache.has(id)) return memoryCache.get(id);\n  const stored = loadFromSession(id);\n  if (stored) {\n    memoryCache.set(id, stored);\n    return stored;\n  }\n  const map = await preloadPrices([id]);\n  return map.get(id);\n}\n\nexport function clearCache() {\n  memoryCache.clear();\n  if (isSessionStrategy() && typeof sessionStorage !== 'undefined') {\n    for (let i = sessionStorage.length - 1; i >= 0; i--) {\n      const key = sessionStorage.key(i);\n      if (key && key.startsWith('price_')) {\n        sessionStorage.removeItem(key);\n      }\n    }\n  }\n}\n","import { preloadPrices } from './priceHelper.js';\nimport apiHealth from './apiHealth.js';\n\nexport function startPriceUpdater(ids = [], applyFn, interval = 60000) {\n  if (!Array.isArray(ids) || ids.length === 0) return () => {};\n  let stopped = false;\n\n  async function tick() {\n    if (stopped) return;\n    const delay = apiHealth.getBackoff();\n    if (delay) await new Promise(res => setTimeout(res, delay));\n    try {\n      const map = await preloadPrices(ids);\n      if (typeof applyFn === 'function') applyFn(map);\n    } catch (e) {\n      apiHealth.recordFailure();\n    }\n    if (!stopped) setTimeout(tick, interval);\n  }\n\n  tick();\n\n  return () => { stopped = true; };\n}\n\nexport default { startPriceUpdater };\n","import { getCached, setCached } from './cache.js';\nimport fetchWithRetry from './fetchWithRetry.js';\nimport apiHealth from './apiHealth.js';\nimport config from '../config.js';\n\nconst GW2_ITEMS_ENDPOINT = `${config.API_BASE_URL}/items?ids=`;\nconst LANG_PARAM = `&lang=${config.LANG}`;\nconst MAX_BATCH = 200;\nconst FLUSH_MS = 50;\n\nconst queue = new Set();\nconst pending = new Map();\nlet timer = null;\nlet controller = null;\n\nfunction buildHeaders(ids) {\n  if (ids.length !== 1) return {};\n  const cached = getCached(`item_${ids[0]}`, true);\n  if (!cached) return {};\n  const headers = {};\n  if (cached.etag) headers['If-None-Match'] = cached.etag;\n  if (cached.lastModified) headers['If-Modified-Since'] = cached.lastModified;\n  return headers;\n}\n\n// Precarga en memoria los items cacheados recientemente\nfunction preloadCache() {\n  if (typeof localStorage === 'undefined') return;\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    if (key.startsWith('item_')) getCached(key);\n  }\n}\npreloadCache();\n\nfunction scheduleFlush() {\n  if (!timer) {\n    timer = setTimeout(flush, FLUSH_MS);\n  }\n  if (queue.size >= MAX_BATCH) {\n    clearTimeout(timer);\n    flush();\n  }\n}\n\nasync function flush() {\n  if (queue.size === 0) {\n    timer = null;\n    return;\n  }\n  timer = null;\n  const ids = Array.from(queue).slice(0, MAX_BATCH);\n  ids.forEach(id => queue.delete(id));\n  try {\n    const extraDelay = apiHealth.getBackoff();\n    if (extraDelay) await new Promise(res => setTimeout(res, extraDelay));\n    controller = new AbortController();\n    const res = await fetchWithRetry(GW2_ITEMS_ENDPOINT + ids.join(',') + LANG_PARAM, {\n      headers: buildHeaders(ids),\n      signal: controller.signal,\n      backoff: 300 + extraDelay\n    });\n    if (res.status === 304) {\n      ids.forEach(id => {\n        const entry = pending.get(id);\n        const cached = getCached(`item_${id}`);\n        if (entry) entry.resolve(cached);\n        pending.delete(id);\n      });\n      return;\n    }\n    const etag = res.headers.get('ETag');\n    const lastModified = res.headers.get('Last-Modified');\n    const data = await res.json();\n    const dataMap = new Map(data.map(item => [item.id, item]));\n    ids.forEach(id => {\n      const entry = pending.get(id);\n      const item = dataMap.get(id);\n      if (item) {\n        setCached(`item_${id}`, item, undefined, { etag, lastModified });\n        entry.resolve(item);\n      } else {\n        entry.resolve(null);\n      }\n      pending.delete(id);\n    });\n  } catch (err) {\n    ids.forEach(id => {\n      const entry = pending.get(id);\n      if (entry) {\n        if (err instanceof DOMException && err.name === 'AbortError') {\n          entry.reject(err);\n        } else {\n          entry.reject(err);\n        }\n      }\n      pending.delete(id);\n    });\n  }\n  if (queue.size > 0) {\n    scheduleFlush();\n  }\n}\n\nexport function requestItems(ids = [], signal) {\n  if (controller) {\n    controller.abort();\n    controller = null;\n  }\n  if (signal) {\n    signal.addEventListener('abort', () => controller && controller.abort(), { once: true });\n  }\n  const promises = ids.map(id => {\n    const cached = getCached(`item_${id}`);\n    if (cached) return Promise.resolve(cached);\n    if (pending.has(id)) return pending.get(id).promise;\n    const entry = {};\n    entry.promise = new Promise((resolve, reject) => {\n      entry.resolve = resolve;\n      entry.reject = reject;\n    });\n    pending.set(id, entry);\n    queue.add(id);\n    scheduleFlush();\n    return entry.promise;\n  });\n  return Promise.all(promises);\n}\n\nexport function abortRequests() {\n  if (controller) {\n    controller.abort();\n    controller = null;\n  }\n  queue.clear();\n  pending.forEach(entry => entry.reject(new DOMException('Aborted', 'AbortError')));\n  pending.clear();\n  if (timer) {\n    clearTimeout(timer);\n    timer = null;\n  }\n}\n","const renderers = new Map();\nconst visibility = new WeakMap();\n\nconst observer = new IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    const el = entry.target;\n    visibility.set(el, entry.isIntersecting);\n    if (entry.isIntersecting) {\n      const id = el.dataset.stateId || el.dataset.path;\n      if (!id) return;\n      const list = renderers.get(id);\n      if (!list) return;\n      const item = list.find(r => r.el === el);\n      const data = el._pendingState;\n      if (item && data) {\n        item.renderFn(data);\n        el._pendingState = null;\n      }\n    }\n  });\n});\n\nexport function register(id, el, renderFn) {\n  const key = String(id);\n  el.dataset.stateId = key;\n  let list = renderers.get(key);\n  if (!list) {\n    list = [];\n    renderers.set(key, list);\n  }\n  list.push({ el, renderFn });\n  observer.observe(el);\n}\n\nexport function update(id, data) {\n  const list = renderers.get(String(id));\n  if (!list) return;\n  list.forEach(({ el, renderFn }) => {\n    if (visibility.get(el)) {\n      renderFn && renderFn(data);\n    } else {\n      el._pendingState = data;\n    }\n  });\n}\n","export function initLazyImages() {\n  const io = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;\n        io.unobserve(img);\n      }\n    });\n  });\n  document.querySelectorAll('img[data-src]').forEach(img => io.observe(img));\n}\n\nexport function observeSection(el, callback) {\n  if (!el) return;\n  const io = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        callback();\n        io.unobserve(entry.target);\n      }\n    });\n  });\n  io.observe(el);\n}\n"],"names":["failureTimestamps","cleanup","cutoff","Date","now","length","shift","getState","fails","indicatorEl","updateIndicator","document","state","createElement","id","style","position","bottom","right","padding","background","color","borderRadius","zIndex","display","body","appendChild","textContent","apiHealth","recordFailure","push","recordSuccess","getBackoff","async","fetchWithRetry","url","options","timeout","retries","backoff","signal","fetchOptions","attempt","controller","AbortController","timeoutId","setTimeout","abort","aborted","addEventListener","once","response","fetch","clearTimeout","err","delay","Math","pow","Promise","res","CACHE_TTLS","item","recipe","price","history","bundle","channel","window","BroadcastChannel","store","notifyDelete","key","postMessage","type","cacheStore","Map","data","entry","set","delete","forEach","e","k","startsWith","setupCacheSync","STORAGE_AVAILABLE","localStorage","inFlight","deserializeEntry","raw","JSON","parse","writeStorage","setItem","value","expiresAt","etag","lastModified","stringify","serializeEntry","setCached","ttlMs","undefined","meta","prefix","split","updatedAt","toISOString","notifySet","getCached","withMeta","get","getItem","removeItem","readStorage","fetchDedup","method","headers","toUpperCase","requestKey","base","finally","then","clone","keysToRemove","i","cleanExpired","activeRequests","fetchWithCache","cacheKey","cached","existing","fetchSignal","promise","setRequest","status","Response","ETag","catch","DOMException","name","r","ENV","process","env","API_BASE_URL","LANG","MARKET_CSV_URL","GW2_API_KEY","config","PRICE_CACHE_STRATEGY","memoryCache","isSessionStrategy","storageKey","loadFromSession","sessionStorage","expires","preloadPrices","ids","result","toFetch","Number","has","stored","fetched","Array","isArray","join","resp","ok","Error","arr","json","out","m","market","buy_price","sell_price","lines","text","trim","values","obj","h","idx","v","isNaN","fetchPrices","saveToSession","console","error","getPrice","clearCache","clear","startPriceUpdater","applyFn","interval","stopped","tick","map","GW2_ITEMS_ENDPOINT","LANG_PARAM","queue","Set","pending","timer","buildHeaders","scheduleFlush","flush","size","from","slice","extraDelay","resolve","dataMap","reject","requestItems","promises","add","all","preloadCache","renderers","visibility","WeakMap","observer","IntersectionObserver","entries","el","target","isIntersecting","dataset","stateId","path","list","find","_pendingState","renderFn","register","String","observe","update","initLazyImages","io","img","src","unobserve","querySelectorAll","observeSection","callback"],"mappings":"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"}